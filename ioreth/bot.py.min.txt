#
# Ioreth - An APRS library and bot
# Copyright (C) 2020  Alexandre Erwin Ittner, PP5ITT <alexandre@ittner.com.br>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#

import sys
import time
import logging
import configparser
import os
import re
import random
import sqlite3
import threading

logging.basicConfig()
logger = logging.getLogger(__name__)

from cronex import CronExpression

from .clients import AprsClient
#from . import aprs
from . import remotecmd
from . import utils
import aprs
import aprslib
packet = aprslib.parse("W1AW>APRS,TCPIP*:Hello world")
print(packet)



def is_br_callsign(callsign):
    return bool(re.match("P[PTUY][0-9].+", callsign.upper()))
#################

import threading
import logging
import aprs

import threading
import logging
import aprs

class BotAprsHandler(aprs.TCP):
    def __init__(self, callsign, passcode, client):
        super().__init__(
            user=callsign.encode("utf-8"),
            password=passcode,
            aprs_filter=b"b/ERLI"
        )
        self.callsign = callsign
        self._client = client
        self._running = False

    def start(self):
        super().start()
        self._running = True
        threading.Thread(target=self._read_loop, daemon=True).start()
        logging.info("APRS-IS read loop started.")

    def _read_loop(self):
        while self._running:
            try:
                raw = self.read()
                if raw:
                    logging.info(f"[APRS RAW] {raw}")
                    try:
                        # Attempt to parse the raw frame into a structured object
                        parsed = aprs.Frame(raw)
                        logging.debug(f"Parsed Frame: source={parsed.source}, destination={parsed.destination}, text={parsed.text}")
                    
                        # Route the frame to the client's receive handler
                        if self._client and hasattr(self._client, "on_recv_frame"):
                            self._client.on_recv_frame(parsed)
                    except Exception as e:
                        logging.warning(f"Failed to parse APRS frame: {e} â€” raw={raw}")
            except Exception as e:
                logging.error(f"APRS read error: {e}")
                self._running = False


    def is_connected(self):
        return self._sock is not None and not self._sock._closed

    def send_aprs_msg(self, to_call, text, from_call=None):
        source = from_call or self.callsign
        frame = f"{source}>{to_call}:{text}"
        logging.info(f"Sending frame: {frame}")
        self.send(frame.encode("utf-8"))

        
        
class SystemStatusCommand(remotecmd.BaseRemoteCommand):
    def __init__(self, cfg):
        remotecmd.BaseRemoteCommand.__init__(self, "system-status")
        self._cfg = cfg
        self.status_str = ""

    def run(self):
        net_status = (
            self._check_host_scope("Eth", "eth_host")
            + self._check_host_scope("Inet", "inet_host")
            + self._check_host_scope("DNS", "dns_host")
            + self._check_host_scope("VPN", "vpn_host")
        )
        self.status_str = "At %s: Uptime %s" % (
            time.strftime("%Y-%m-%d %H:%M:%S UTC%Z"),
            utils.human_time_interval(utils.get_uptime()),
        )
        if len(net_status) > 0:
            self.status_str += "," + net_status

    def _check_host_scope(self, label, cfg_key):
        if not cfg_key in self._cfg:
            return ""
        ret = utils.simple_ping(self._cfg[cfg_key])
        return " " + label + (":Ok" if ret else ":Err")


class ReplyBot(AprsClient):
    def __init__(self, config_file):
        super().__init__()
        self._config_file = config_file
        self._cfg = configparser.ConfigParser()
        self._cfg.optionxform = str
        self._cfg.read(self._config_file)

        # Pull credentials from config
        callsign = self._cfg.get("aprs", "callsign")
        passcode = self._cfg.get("aprs", "passcode")


        self._aprs = BotAprsHandler(callsign, passcode, self)
        self._aprs._client = self  # ðŸ‘ˆ This ensures callbacks go to this bot instance
        self._last_blns = time.monotonic()
        self._last_cron_blns = 0
        self._last_status = time.monotonic()
        self._last_reconnect_attempt = 0
        self._rem = remotecmd.RemoteCommandHandler()

    def is_connected(self):
        return self._aprs and hasattr(self._aprs, '_sock') and self._aprs._sock and not self._aprs._sock._closed

    def connect(self):
        pass  # Do nothing â€” handled by BotAprsHandler

    def loop(self):
        while True:
            self.on_loop_hook()
            time.sleep(1)

    def on_connect(self):
        logger.info("Connected")

    def on_disconnect(self):
        logger.warning("KSS Disconnected! Will try again soon...")

    def on_recv_frame(self, frame):
        logging.info(f"RECV FRAME: {frame}")
        logging.debug(f"FRAME DIR: {dir(frame)}")
        logging.debug(f"FRAME VARS: {vars(frame)}")

        # âœ… 1. Handle direct messages (e.g. KC2NJV-7>ERLI: ping)
        if hasattr(frame, "destination") and hasattr(frame, "text"):
            if frame.destination.strip().upper() == self._aprs.callsign.upper():
                self._aprs.on_aprs_message(
                    source=frame.source,
                    addressee=frame.destination,
                    text=frame.text,
                    origframe=str(frame)
                )
                return

        # âœ… 2. Handle third-party messages (e.g. ::ERLI     :ping)
        if hasattr(frame, "text") and frame.text.startswith("::"):
            try:
                addr_field = frame.text[2:11].strip()
                body = frame.text[11:].strip()
                self._aprs.on_aprs_message(
                    source=frame.source,
                    addressee=addr_field,
                    text=body,
                    origframe=str(frame)
                )
                return
            except Exception as e:
                logging.warning(f"Failed to parse APRS message: {e}")

        # âœ… 3. Fallback: catch unstructured or raw frames
        if hasattr(frame, "line"):
            raw = frame.line
            logging.info(f"RAW LINE: {raw}")
            if ">ERLI:" in raw.upper():  # ensure case-insensitive match
                try:
                    parts = raw.split(">", 1)
                    if len(parts) == 2:
                        src, rest = parts
                        dst, msg = rest.split(":", 1)
                        self._aprs.on_aprs_message(
                            source=src.strip(),
                            addressee=dst.strip(),
                            text=msg.strip(),
                            origframe=raw
                        )
                except Exception as e:
                    logging.warning(f"Failed to fallback-parse frame: {e}")
       
        
    def on_loop_hook(self):
        super().on_loop_hook()
#        self._check_reconnection()
        self._update_bulletins()
        self._update_status()

        # Handle any remote command results
        while True:
            cmd = self._rem.poll_ret()
            if not cmd:
                break
            self.on_remote_command_result(cmd)

    def _check_reconnection(self):
        if self.is_connected():
            return
        now = time.monotonic()
        if now > self._last_reconnect_attempt + 5:
            self._last_reconnect_attempt = now
            logger.info("Attempting reconnect to APRS-IS")
            try:
                self.connect()
            except Exception as e:
                logger.warning(f"Reconnect failed: {e}")

    def _update_bulletins(self):
        if not self._cfg.has_section("bulletins"):
            return
        max_age = self._cfg.getint("bulletins", "send_freq", fallback=600)
        now = time.monotonic()
        if now <= (self._last_blns + max_age):
            return
        self._last_blns = now

        for key in sorted(self._cfg.options("bulletins")):
            if key.upper().startswith("BLN"):
                message = self._cfg.get("bulletins", key)
                logger.info(f"Sending bulletin {key}: {message}")
                self._aprs.send_aprs_msg(key, message)

    def _update_status(self):
        if not self._cfg.has_section("status"):
            return
        max_age = self._cfg.getint("status", "send_freq", fallback=600)
        now = time.monotonic()
        if now <= (self._last_status + max_age):
            return
        self._last_status = now
        cmd = SystemStatusCommand(self._cfg["status"])
        self._rem.post_cmd(cmd)

    def on_remote_command_result(self, cmd):
        if not hasattr(self._aprs, 'send_aprs_status'):
            logging.warning("APRS handler lacks status sending â€” skipping.")
            return

        if isinstance(cmd, SystemStatusCommand):
            self._aprs.send_aprs_status(cmd.status_str)

